{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DipCoin Python SDK","text":"<p>DipCoin Python SDK is a powerful and easy-to-use library for interacting with the DipCoin Protocol on the Sui blockchain. This SDK provides a comprehensive set of tools for managing liquidity pools, performing swaps, and interacting with the DipCoin ecosystem.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd04 Liquidity Pool Management</li> <li>Add liquidity to pools</li> <li>Remove liquidity from pools</li> <li>Query pool information and IDs</li> <li>\ud83d\udcb1 Token Swaps</li> <li>Exact input swaps (swap_exact_in)</li> <li>Exact output swaps (swap_exact_out)</li> <li>\ud83d\udd0d Pool Discovery</li> <li>Find pool IDs for token pairs</li> <li>Query pool details and statistics</li> <li>\u26a1 Transaction Management</li> <li>Automatic coin splitting and merging</li> <li>Transaction execution and status tracking</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dipcoin\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example of how to use the DipCoin SDK:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def main():\n    # Initialize the client (defaults to testnet)\n    client = DipcoinClient()\n\n    # Get pool information\n    pool = await client.get_pool(\"your_pool_id\")\n\n    # Add liquidity to a pool\n    result = await client.add_liquidity(\n        coin_x_type=\"0x2::sui::SUI\",\n        coin_y_type=\"0x2::usdc::USDC\",\n        coin_x_amount=1000000000,  # 1 SUI\n        coin_y_amount=1000000,     # 1 USDC\n        slippage=0.005             # 0.5% slippage\n    )\n\n    # Perform a swap\n    swap_result = await client.swap_exact_in(\n        coin_in_type=\"0x2::sui::SUI\",\n        coin_out_type=\"0x2::usdc::USDC\",\n        amount_in=1000000000,      # 1 SUI\n        slippage=0.005             # 0.5% slippage\n    )\n\n# Run the async function\nimport asyncio\nasyncio.run(main())\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Tutorials - Step-by-step guides for common use cases</li> <li>API Reference - Detailed documentation of all available methods and classes</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For support, please join our community or open an issue on GitHub.</p>"},{"location":"reference/","title":"Reference","text":"<p>Dipcoin Python SDK</p>"},{"location":"reference/#dipcoin.client.DipcoinClient","title":"<code>DipcoinClient</code>","text":"<p>A client for interacting with the Dipcoin Protocol on Sui blockchain.</p> <p>This client provides methods to interact with Dipcoin's liquidity pools, including adding/removing liquidity and performing swaps.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>str</code> <p>The network to connect to (e.g., \"testnet\", \"mainnet\")</p> <code>client</code> <code>AsyncGqlClient</code> <p>The Sui GraphQL client instance</p> Source code in <code>dipcoin/client.py</code> <pre><code>class DipcoinClient:\n    \"\"\"A client for interacting with the Dipcoin Protocol on Sui blockchain.\n\n    This client provides methods to interact with Dipcoin's liquidity pools,\n    including adding/removing liquidity and performing swaps.\n\n    Attributes:\n        network (str): The network to connect to (e.g., \"testnet\", \"mainnet\")\n        client (AsyncGqlClient): The Sui GraphQL client instance\n    \"\"\"\n\n    def __init__(\n        self, \n        network: str = \"testnet\"\n    ):\n        \"\"\"Initialize the Dipcoin client.\n\n        Args:\n            network (str, optional): The network to connect to. Defaults to \"testnet\".\n        \"\"\"\n        cfg = PysuiConfiguration(group_name=PysuiConfiguration.SUI_GQL_RPC_GROUP )\n        self.client = AsyncGqlClient(pysui_config=cfg,write_schema=False)\n        self.query = DipCoinQuery(network)\n        self.network = network\n\n    async def get_pool(self, pool_id: str) -&gt; Pool | None:\n        \"\"\"Retrieve information about a specific liquidity pool.\n\n        Args:\n            pool_id (str): The unique identifier of the pool to query.\n\n        Returns:\n            Pool | None: A Pool object containing the pool's information if found,\n                        None if the pool doesn't exist.\n\n        Raises:\n            Exception: If there's an error parsing the pool data or an unknown error occurs.\n        \"\"\"\n        qres = await self.client.execute_query_node(\n            with_node=qn.GetObject(\n                object_id=pool_id\n            )\n        )\n        res = handle_result(qres)\n        if isinstance(res, ObjectReadGQL):\n            try:\n                return Pool.from_gql_response(res.content)\n            except:\n                raise UnreachableException(f\"Unknown error: {res}\")\n        elif isinstance(res, NoopGQL):\n            return None\n        else:\n            raise UnreachableException(f\"Unknown error: {res}\")\n\n    async def get_pool_id(self, coin_x_type: str, coin_y_type: str) -&gt; str | None:\n        \"\"\"Get the pool ID for a given pair of tokens.\n\n        Args:\n            coin_x_type (str): The type of the first token in the pair.\n            coin_y_type (str): The type of the second token in the pair.\n\n        Returns:\n            str | None: The pool ID if found, None if no pool exists for the given pair.\n        \"\"\"\n        return await self.query.get_pool_id(coin_x_type, coin_y_type)\n\n    async def add_liquidity(\n        self,\n        coin_x_type: str,\n        coin_y_type: str,\n        coin_x_amount: int,\n        coin_y_amount: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; TransactionResponse:\n        \"\"\"Add liquidity to a pool.\n\n        This method allows users to provide liquidity to a pool by depositing both tokens\n        in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.\n\n        Args:\n            coin_x_type (str): The type of the first token.\n            coin_y_type (str): The type of the second token.\n            coin_x_amount (int): The amount of the first token to deposit.\n            coin_y_amount (int): The amount of the second token to deposit.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n        Returns:\n            TransactionResponse: A TransactionResponse object containing the transaction digest and status\n        \"\"\"\n        try:\n            # Ensure correct order of typeX and typeY\n            new_type_x, new_type_y = sort_type(coin_x_type, coin_y_type)\n            is_change = new_type_x != coin_x_type\n            coin_x_type = new_type_x\n            coin_y_type = new_type_y\n\n            if is_change:\n                coin_x_amount, coin_y_amount = coin_y_amount, coin_x_amount\n\n            # Validate input amounts\n            if coin_x_amount &lt;= 0 or coin_y_amount &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n            # Get pool information\n            pool_id = await self.query.get_pool_id(coin_x_type, coin_y_type)\n            if not pool_id:\n                raise PoolNotFound(coin_x_type, coin_y_type)\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise PoolNotFound(coin_x_type, coin_y_type)\n\n            # Calculate optimal amounts\n            coin_x_desired, coin_y_desired = calc_optimal_coin_values(\n                coin_x_amount,\n                coin_y_amount,\n                pool.bal_x,\n                pool.bal_y,\n            )\n            # Calculate minimum accepted amounts (considering slippage)\n            coin_x_min = int(coin_x_desired * (1.0 - slippage))\n            coin_y_min = int(coin_y_desired * (1.0 - slippage))\n\n            # Create transaction\n            txn = SuiTransaction(client=self.client)\n\n            # Split X token\n            split_coin_x = await self._split_coin(\n                self.client.config.active_address,\n                coin_x_type,\n                coin_x_amount,\n                txn\n            )\n\n            # Split Y token\n            split_coin_y = await self._split_coin(\n                self.client.config.active_address,\n                coin_y_type,\n                coin_y_amount,\n                txn\n            )\n\n            # Call contract to add liquidity\n            await txn.move_call(\n                target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::add_liquidity\",\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_x,\n                    coin_x_min,\n                    split_coin_y,\n                    coin_y_min\n                ],\n                type_arguments=[coin_x_type, coin_y_type]\n            )\n            # Execute transaction\n            final_result = await self._execute_and_wait(txn)\n            # TODO: check effects\n            # if final_result.is_ok():\n            #     res = handle_result(final_result)\n            #     print(type(res.effects))\n            #     print(res.effects['balanceChanges']['nodes'])\n            # elif final_result.is_err():\n            #     print(final_result.result_string)\n            # else:\n            #     raise UnreachableException(f\"Unknown error: {final_result}\")\n\n            return final_result\n\n        except Exception as e:\n            return TransactionResponse(\n                digest=\"\",\n                status=False,\n                error=str(e)\n            )\n\n    async def remove_liquidity(\n        self,\n        coin_x_type: str,\n        coin_y_type: str,\n        lp_amount: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; TransactionResponse:\n        \"\"\"Remove liquidity from a pool.\n\n        This method allows users to withdraw their liquidity from a pool by burning\n        their LP tokens. The user will receive both tokens in the pair in proportion\n        to their share of the pool.\n\n        Args:\n            coin_x_type (str): The type of the first token in the pair.\n            coin_y_type (str): The type of the second token in the pair.\n            lp_amount (int): The amount of LP tokens to burn.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to 0.5%.\n        Returns:\n            TransactionResponse: A TransactionResponse object containing the transaction digest and status\n        \"\"\"\n        try:\n            if lp_amount &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n            coin_x_type, coin_y_type, lp_type = sort_and_get_lp_type(\n                CONTRACT_CONSTANTS[self.network].package_id,\n                coin_x_type,\n                coin_y_type\n            )\n\n            # Get pool info\n            pool_id = await self.query.get_pool_id(coin_x_type, coin_y_type)\n            if not pool_id:\n                raise PoolNotFound(coin_x_type, coin_y_type)\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            expected_coin_x_out = pool.bal_x * lp_amount // pool.lp_supply\n            expected_coin_y_out = pool.bal_y * lp_amount // pool.lp_supply\n            coin_x_min = int(expected_coin_x_out * (1.0 - slippage))\n            coin_y_min = int(expected_coin_y_out * (1.0 - slippage))\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split LP coin\n            split_lp_coin = await self._split_coin(\n                self.client.config.active_address,\n                lp_type,\n                lp_amount,\n                txn\n            )\n\n            # Call contract to remove liquidity\n            await txn.move_call(\n                target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::remove_liquidity\",\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_lp_coin,\n                    coin_x_min,\n                    coin_y_min\n                ],\n                type_arguments=[coin_x_type, coin_y_type]\n            )\n\n            # Execute transaction\n            return await self._execute_and_wait(txn)\n\n        except Exception as e:\n            return TransactionResponse(\n                digest=\"\",\n                status=False,\n                error=str(e)\n            )\n\n    async def swap_exact_in(\n        self,\n        coin_in_type: str,\n        coin_out_type: str,\n        amount_in: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; TransactionResponse:\n        \"\"\"Swap an exact amount of input tokens for output tokens.\n\n        This method performs a swap where the user specifies the exact amount of input\n        tokens they want to spend. The output amount is calculated based on the pool's\n        current price and liquidity.\n\n        Args:\n            coin_in_type (str): The type of the input token.\n            coin_out_type (str): The type of the output token.\n            amount_in (int): The exact amount of input tokens to spend.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to 0.5%.\n\n        Returns:\n            TransactionResponse: A TransactionResponse object containing the transaction digest and status\n        \"\"\"\n        try:\n            if amount_in &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n            pool_id = await self.query.get_pool_id(coin_in_type, coin_out_type)\n            if not pool_id:\n                raise PoolNotFound(coin_in_type, coin_out_type)\n\n            # Get pool info\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split X coin\n            split_coin_in = await self._split_coin(\n                self.client.config.active_address,\n                coin_in_type,\n                amount_in,\n                txn\n            )\n\n            if coin_in_type == pool_x_type:\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_x_to_y\"\n                reverse_in = pool.bal_x\n                reverse_out = pool.bal_y\n            else:\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_y_to_x\"\n                reverse_in = pool.bal_y\n                reverse_out = pool.bal_x\n\n            expected_amount_out = get_amount_out(\n                pool.fee_rate,\n                amount_in,\n                reverse_in,\n                reverse_out\n            )\n            # Calculate minimum output amount (considering slippage)\n            min_amount_out = int(expected_amount_out * (1.0 - slippage))\n\n            # Call contract to swap\n            await txn.move_call(\n                target=target,\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_in,\n                    min_amount_out\n                ],\n                type_arguments=[pool_x_type, pool_y_type]\n            )\n\n            # Execute transaction\n            return await self._execute_and_wait(txn)\n\n        except Exception as e:\n            return TransactionResponse(\n                digest=\"\",\n                status=False,\n                error=str(e)\n            )\n\n    async def swap_exact_out(\n        self,\n        coin_in_type: str,\n        coin_out_type: str,\n        amount_out: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; TransactionResponse:\n        \"\"\"Swap input tokens for an exact amount of output tokens.\n\n        This method performs a swap where the user specifies the exact amount of output\n        tokens they want to receive. The required input amount is calculated based on\n        the pool's current price and liquidity.\n\n        Args:\n            coin_in_type (str): The type of the input token.\n            coin_out_type (str): The type of the output token.\n            amount_out (int): The exact amount of output tokens to receive.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n        Returns:\n            TransactionResponse: A TransactionResponse object containing the transaction digest and status\n        \"\"\"\n        try:\n            if amount_out &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n            # Get pool info\n            pool_id = await self.query.get_pool_id(coin_in_type, coin_out_type)\n            if not pool_id:\n                raise PoolNotFound(coin_in_type, coin_out_type)\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n            if pool_x_type == coin_in_type:\n                reverse_in = pool.bal_x\n                reverse_out = pool.bal_y\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_x_to_exact_y\"\n            else:\n                reverse_in = pool.bal_y\n                reverse_out = pool.bal_x\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_y_to_exact_x\"\n\n            expected_amount_in = get_amount_in(\n                pool.fee_rate,\n                amount_out,\n                reverse_in,\n                reverse_out\n            )\n            max_amount_in = int(expected_amount_in / (1.0 - slippage))\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split X coin\n            split_coin_in = await self._split_coin(\n                self.client.config.active_address,\n                coin_in_type,\n                max_amount_in,\n                txn\n            )\n\n            # Call contract to swap\n            await txn.move_call(\n                target=target,\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_in,\n                    amount_out\n                ],\n                type_arguments=[pool_x_type, pool_y_type]\n            )\n\n            # Execute transaction\n            return await self._execute_and_wait(txn)\n\n        except Exception as e:\n            return TransactionResponse(\n                digest=\"\",\n                status=False,\n                error=str(e)\n            )\n\n    async def _execute_and_wait(self, txn: SuiTransaction) -&gt; TransactionResponse:\n        \"\"\"Execute transaction and wait for it to be processed\"\"\"\n        tx_data = await txn.build_and_sign()\n        tx_result = await txn.client.execute_query_node(\n            with_node=qn.ExecuteTransaction(**tx_data)\n        )\n        if tx_result.is_err():\n            return TransactionResponse(\n                digest=\"\",\n                status=False,\n                error=tx_result.result_string\n            )\n        tx_result = handle_result(tx_result)\n        assert tx_result.status == 'SUCCESS', tx_result.status\n        await self.client.wait_for_transaction(digest=tx_result.digest) # TODO: check effects\n        return TransactionResponse(\n            digest=tx_result.digest,\n            status=True\n        )\n\n\n    async def _split_coin(\n        self,\n        owner_address: str,\n        coin_type: str,\n        amount: int,\n        txn: SuiTransaction\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Split coin\n\n        Args:\n            owner_address: Owner address\n            coin_type: Coin type\n            amount: Split amount\n            txn: Transaction object\n\n        Returns:\n            Dict[str, Any]: Split coin info\n        \"\"\"\n        # Get coin list\n        coins = await self.client.execute_query_node(\n            with_node=qn.GetCoins(\n                owner=owner_address,\n                coin_type=coin_type\n            )\n        )\n        coins_data = handle_result(coins)\n\n        if not coins_data or len(coins_data.data) == 0:\n            raise ValueError(f\"no {coin_type} coins available\")\n\n        # Filter out enough coins\n        selected_coins = []\n        total_amount = 0\n        for coin in coins_data.data:\n            selected_coins.append(coin.coin_object_id)\n            total_amount += int(coin.balance)\n            if total_amount &gt;= amount:\n                break\n\n        if not selected_coins or total_amount &lt; amount:\n            raise ValueError(\n                f\"{coin_type} balance is not enough, current total balance:{total_amount}\"\n            )\n\n        # Merge coins (if selected coins are more than 1)\n        if len(selected_coins) &gt; 1:\n            await txn.merge_coins(\n                merge_to=selected_coins[0],\n                merge_from=selected_coins[1:],\n            )\n\n        # Split out the specified amount of coins\n        split_result = await txn.split_coin(\n            coin=selected_coins[0],\n            amounts=[amount]\n        )\n        return split_result\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.__init__","title":"<code>__init__(network='testnet')</code>","text":"<p>Initialize the Dipcoin client.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>str</code> <p>The network to connect to. Defaults to \"testnet\".</p> <code>'testnet'</code> Source code in <code>dipcoin/client.py</code> <pre><code>def __init__(\n    self, \n    network: str = \"testnet\"\n):\n    \"\"\"Initialize the Dipcoin client.\n\n    Args:\n        network (str, optional): The network to connect to. Defaults to \"testnet\".\n    \"\"\"\n    cfg = PysuiConfiguration(group_name=PysuiConfiguration.SUI_GQL_RPC_GROUP )\n    self.client = AsyncGqlClient(pysui_config=cfg,write_schema=False)\n    self.query = DipCoinQuery(network)\n    self.network = network\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.add_liquidity","title":"<code>add_liquidity(coin_x_type, coin_y_type, coin_x_amount, coin_y_amount, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Add liquidity to a pool.</p> <p>This method allows users to provide liquidity to a pool by depositing both tokens in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.</p> <p>Parameters:</p> Name Type Description Default <code>coin_x_type</code> <code>str</code> <p>The type of the first token.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token.</p> required <code>coin_x_amount</code> <code>int</code> <p>The amount of the first token to deposit.</p> required <code>coin_y_amount</code> <code>int</code> <p>The amount of the second token to deposit.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to DEFAULT_SLIPPAGE (0.5%).</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Name Type Description <code>TransactionResponse</code> <code>TransactionResponse</code> <p>A TransactionResponse object containing the transaction digest and status</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def add_liquidity(\n    self,\n    coin_x_type: str,\n    coin_y_type: str,\n    coin_x_amount: int,\n    coin_y_amount: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; TransactionResponse:\n    \"\"\"Add liquidity to a pool.\n\n    This method allows users to provide liquidity to a pool by depositing both tokens\n    in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.\n\n    Args:\n        coin_x_type (str): The type of the first token.\n        coin_y_type (str): The type of the second token.\n        coin_x_amount (int): The amount of the first token to deposit.\n        coin_y_amount (int): The amount of the second token to deposit.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n    Returns:\n        TransactionResponse: A TransactionResponse object containing the transaction digest and status\n    \"\"\"\n    try:\n        # Ensure correct order of typeX and typeY\n        new_type_x, new_type_y = sort_type(coin_x_type, coin_y_type)\n        is_change = new_type_x != coin_x_type\n        coin_x_type = new_type_x\n        coin_y_type = new_type_y\n\n        if is_change:\n            coin_x_amount, coin_y_amount = coin_y_amount, coin_x_amount\n\n        # Validate input amounts\n        if coin_x_amount &lt;= 0 or coin_y_amount &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n        # Get pool information\n        pool_id = await self.query.get_pool_id(coin_x_type, coin_y_type)\n        if not pool_id:\n            raise PoolNotFound(coin_x_type, coin_y_type)\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise PoolNotFound(coin_x_type, coin_y_type)\n\n        # Calculate optimal amounts\n        coin_x_desired, coin_y_desired = calc_optimal_coin_values(\n            coin_x_amount,\n            coin_y_amount,\n            pool.bal_x,\n            pool.bal_y,\n        )\n        # Calculate minimum accepted amounts (considering slippage)\n        coin_x_min = int(coin_x_desired * (1.0 - slippage))\n        coin_y_min = int(coin_y_desired * (1.0 - slippage))\n\n        # Create transaction\n        txn = SuiTransaction(client=self.client)\n\n        # Split X token\n        split_coin_x = await self._split_coin(\n            self.client.config.active_address,\n            coin_x_type,\n            coin_x_amount,\n            txn\n        )\n\n        # Split Y token\n        split_coin_y = await self._split_coin(\n            self.client.config.active_address,\n            coin_y_type,\n            coin_y_amount,\n            txn\n        )\n\n        # Call contract to add liquidity\n        await txn.move_call(\n            target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::add_liquidity\",\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_x,\n                coin_x_min,\n                split_coin_y,\n                coin_y_min\n            ],\n            type_arguments=[coin_x_type, coin_y_type]\n        )\n        # Execute transaction\n        final_result = await self._execute_and_wait(txn)\n        # TODO: check effects\n        # if final_result.is_ok():\n        #     res = handle_result(final_result)\n        #     print(type(res.effects))\n        #     print(res.effects['balanceChanges']['nodes'])\n        # elif final_result.is_err():\n        #     print(final_result.result_string)\n        # else:\n        #     raise UnreachableException(f\"Unknown error: {final_result}\")\n\n        return final_result\n\n    except Exception as e:\n        return TransactionResponse(\n            digest=\"\",\n            status=False,\n            error=str(e)\n        )\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.get_pool","title":"<code>get_pool(pool_id)</code>  <code>async</code>","text":"<p>Retrieve information about a specific liquidity pool.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The unique identifier of the pool to query.</p> required <p>Returns:</p> Type Description <code>Pool | None</code> <p>Pool | None: A Pool object containing the pool's information if found,         None if the pool doesn't exist.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If there's an error parsing the pool data or an unknown error occurs.</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def get_pool(self, pool_id: str) -&gt; Pool | None:\n    \"\"\"Retrieve information about a specific liquidity pool.\n\n    Args:\n        pool_id (str): The unique identifier of the pool to query.\n\n    Returns:\n        Pool | None: A Pool object containing the pool's information if found,\n                    None if the pool doesn't exist.\n\n    Raises:\n        Exception: If there's an error parsing the pool data or an unknown error occurs.\n    \"\"\"\n    qres = await self.client.execute_query_node(\n        with_node=qn.GetObject(\n            object_id=pool_id\n        )\n    )\n    res = handle_result(qres)\n    if isinstance(res, ObjectReadGQL):\n        try:\n            return Pool.from_gql_response(res.content)\n        except:\n            raise UnreachableException(f\"Unknown error: {res}\")\n    elif isinstance(res, NoopGQL):\n        return None\n    else:\n        raise UnreachableException(f\"Unknown error: {res}\")\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.get_pool_id","title":"<code>get_pool_id(coin_x_type, coin_y_type)</code>  <code>async</code>","text":"<p>Get the pool ID for a given pair of tokens.</p> <p>Parameters:</p> Name Type Description Default <code>coin_x_type</code> <code>str</code> <p>The type of the first token in the pair.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token in the pair.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The pool ID if found, None if no pool exists for the given pair.</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def get_pool_id(self, coin_x_type: str, coin_y_type: str) -&gt; str | None:\n    \"\"\"Get the pool ID for a given pair of tokens.\n\n    Args:\n        coin_x_type (str): The type of the first token in the pair.\n        coin_y_type (str): The type of the second token in the pair.\n\n    Returns:\n        str | None: The pool ID if found, None if no pool exists for the given pair.\n    \"\"\"\n    return await self.query.get_pool_id(coin_x_type, coin_y_type)\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.remove_liquidity","title":"<code>remove_liquidity(coin_x_type, coin_y_type, lp_amount, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Remove liquidity from a pool.</p> <p>This method allows users to withdraw their liquidity from a pool by burning their LP tokens. The user will receive both tokens in the pair in proportion to their share of the pool.</p> <p>Parameters:</p> Name Type Description Default <code>coin_x_type</code> <code>str</code> <p>The type of the first token in the pair.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token in the pair.</p> required <code>lp_amount</code> <code>int</code> <p>The amount of LP tokens to burn.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to 0.5%.</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:     TransactionResponse: A TransactionResponse object containing the transaction digest and status</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def remove_liquidity(\n    self,\n    coin_x_type: str,\n    coin_y_type: str,\n    lp_amount: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; TransactionResponse:\n    \"\"\"Remove liquidity from a pool.\n\n    This method allows users to withdraw their liquidity from a pool by burning\n    their LP tokens. The user will receive both tokens in the pair in proportion\n    to their share of the pool.\n\n    Args:\n        coin_x_type (str): The type of the first token in the pair.\n        coin_y_type (str): The type of the second token in the pair.\n        lp_amount (int): The amount of LP tokens to burn.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to 0.5%.\n    Returns:\n        TransactionResponse: A TransactionResponse object containing the transaction digest and status\n    \"\"\"\n    try:\n        if lp_amount &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n        coin_x_type, coin_y_type, lp_type = sort_and_get_lp_type(\n            CONTRACT_CONSTANTS[self.network].package_id,\n            coin_x_type,\n            coin_y_type\n        )\n\n        # Get pool info\n        pool_id = await self.query.get_pool_id(coin_x_type, coin_y_type)\n        if not pool_id:\n            raise PoolNotFound(coin_x_type, coin_y_type)\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        expected_coin_x_out = pool.bal_x * lp_amount // pool.lp_supply\n        expected_coin_y_out = pool.bal_y * lp_amount // pool.lp_supply\n        coin_x_min = int(expected_coin_x_out * (1.0 - slippage))\n        coin_y_min = int(expected_coin_y_out * (1.0 - slippage))\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split LP coin\n        split_lp_coin = await self._split_coin(\n            self.client.config.active_address,\n            lp_type,\n            lp_amount,\n            txn\n        )\n\n        # Call contract to remove liquidity\n        await txn.move_call(\n            target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::remove_liquidity\",\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_lp_coin,\n                coin_x_min,\n                coin_y_min\n            ],\n            type_arguments=[coin_x_type, coin_y_type]\n        )\n\n        # Execute transaction\n        return await self._execute_and_wait(txn)\n\n    except Exception as e:\n        return TransactionResponse(\n            digest=\"\",\n            status=False,\n            error=str(e)\n        )\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.swap_exact_in","title":"<code>swap_exact_in(coin_in_type, coin_out_type, amount_in, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Swap an exact amount of input tokens for output tokens.</p> <p>This method performs a swap where the user specifies the exact amount of input tokens they want to spend. The output amount is calculated based on the pool's current price and liquidity.</p> <p>Parameters:</p> Name Type Description Default <code>coin_in_type</code> <code>str</code> <p>The type of the input token.</p> required <code>coin_out_type</code> <code>str</code> <p>The type of the output token.</p> required <code>amount_in</code> <code>int</code> <p>The exact amount of input tokens to spend.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to 0.5%.</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Name Type Description <code>TransactionResponse</code> <code>TransactionResponse</code> <p>A TransactionResponse object containing the transaction digest and status</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def swap_exact_in(\n    self,\n    coin_in_type: str,\n    coin_out_type: str,\n    amount_in: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; TransactionResponse:\n    \"\"\"Swap an exact amount of input tokens for output tokens.\n\n    This method performs a swap where the user specifies the exact amount of input\n    tokens they want to spend. The output amount is calculated based on the pool's\n    current price and liquidity.\n\n    Args:\n        coin_in_type (str): The type of the input token.\n        coin_out_type (str): The type of the output token.\n        amount_in (int): The exact amount of input tokens to spend.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to 0.5%.\n\n    Returns:\n        TransactionResponse: A TransactionResponse object containing the transaction digest and status\n    \"\"\"\n    try:\n        if amount_in &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n        pool_id = await self.query.get_pool_id(coin_in_type, coin_out_type)\n        if not pool_id:\n            raise PoolNotFound(coin_in_type, coin_out_type)\n\n        # Get pool info\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split X coin\n        split_coin_in = await self._split_coin(\n            self.client.config.active_address,\n            coin_in_type,\n            amount_in,\n            txn\n        )\n\n        if coin_in_type == pool_x_type:\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_x_to_y\"\n            reverse_in = pool.bal_x\n            reverse_out = pool.bal_y\n        else:\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_y_to_x\"\n            reverse_in = pool.bal_y\n            reverse_out = pool.bal_x\n\n        expected_amount_out = get_amount_out(\n            pool.fee_rate,\n            amount_in,\n            reverse_in,\n            reverse_out\n        )\n        # Calculate minimum output amount (considering slippage)\n        min_amount_out = int(expected_amount_out * (1.0 - slippage))\n\n        # Call contract to swap\n        await txn.move_call(\n            target=target,\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_in,\n                min_amount_out\n            ],\n            type_arguments=[pool_x_type, pool_y_type]\n        )\n\n        # Execute transaction\n        return await self._execute_and_wait(txn)\n\n    except Exception as e:\n        return TransactionResponse(\n            digest=\"\",\n            status=False,\n            error=str(e)\n        )\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.swap_exact_out","title":"<code>swap_exact_out(coin_in_type, coin_out_type, amount_out, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Swap input tokens for an exact amount of output tokens.</p> <p>This method performs a swap where the user specifies the exact amount of output tokens they want to receive. The required input amount is calculated based on the pool's current price and liquidity.</p> <p>Parameters:</p> Name Type Description Default <code>coin_in_type</code> <code>str</code> <p>The type of the input token.</p> required <code>coin_out_type</code> <code>str</code> <p>The type of the output token.</p> required <code>amount_out</code> <code>int</code> <p>The exact amount of output tokens to receive.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to DEFAULT_SLIPPAGE (0.5%).</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Name Type Description <code>TransactionResponse</code> <code>TransactionResponse</code> <p>A TransactionResponse object containing the transaction digest and status</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def swap_exact_out(\n    self,\n    coin_in_type: str,\n    coin_out_type: str,\n    amount_out: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; TransactionResponse:\n    \"\"\"Swap input tokens for an exact amount of output tokens.\n\n    This method performs a swap where the user specifies the exact amount of output\n    tokens they want to receive. The required input amount is calculated based on\n    the pool's current price and liquidity.\n\n    Args:\n        coin_in_type (str): The type of the input token.\n        coin_out_type (str): The type of the output token.\n        amount_out (int): The exact amount of output tokens to receive.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n    Returns:\n        TransactionResponse: A TransactionResponse object containing the transaction digest and status\n    \"\"\"\n    try:\n        if amount_out &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n        # Get pool info\n        pool_id = await self.query.get_pool_id(coin_in_type, coin_out_type)\n        if not pool_id:\n            raise PoolNotFound(coin_in_type, coin_out_type)\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n        if pool_x_type == coin_in_type:\n            reverse_in = pool.bal_x\n            reverse_out = pool.bal_y\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_x_to_exact_y\"\n        else:\n            reverse_in = pool.bal_y\n            reverse_out = pool.bal_x\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_y_to_exact_x\"\n\n        expected_amount_in = get_amount_in(\n            pool.fee_rate,\n            amount_out,\n            reverse_in,\n            reverse_out\n        )\n        max_amount_in = int(expected_amount_in / (1.0 - slippage))\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split X coin\n        split_coin_in = await self._split_coin(\n            self.client.config.active_address,\n            coin_in_type,\n            max_amount_in,\n            txn\n        )\n\n        # Call contract to swap\n        await txn.move_call(\n            target=target,\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_in,\n                amount_out\n            ],\n            type_arguments=[pool_x_type, pool_y_type]\n        )\n\n        # Execute transaction\n        return await self._execute_and_wait(txn)\n\n    except Exception as e:\n        return TransactionResponse(\n            digest=\"\",\n            status=False,\n            error=str(e)\n        )\n</code></pre>"},{"location":"reference/#dipcoin.types.Pool","title":"<code>Pool</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a liquidity pool in the DIP protocol.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier of the pool</p> <code>bal_x</code> <code>int</code> <p>Balance of token X in the pool (U64)</p> <code>bal_y</code> <code>int</code> <p>Balance of token Y in the pool (U64)</p> <code>fee_bal_x</code> <code>int</code> <p>Fee balance of token X (U64)</p> <code>fee_bal_y</code> <code>int</code> <p>Fee balance of token Y (U64)</p> <code>lp_supply</code> <code>int</code> <p>Total supply of LP tokens (U64)</p> <code>fee_rate</code> <code>int</code> <p>Fee rate for swaps (U64)</p> <code>min_liquidity</code> <code>int</code> <p>Minimum liquidity required (U64)</p> Source code in <code>dipcoin/types.py</code> <pre><code>class Pool(BaseModel):\n    \"\"\"\n    Represents a liquidity pool in the DIP protocol.\n\n    Attributes:\n        id (str): Unique identifier of the pool\n        bal_x (int): Balance of token X in the pool (U64)\n        bal_y (int): Balance of token Y in the pool (U64)\n        fee_bal_x (int): Fee balance of token X (U64)\n        fee_bal_y (int): Fee balance of token Y (U64)\n        lp_supply (int): Total supply of LP tokens (U64)\n        fee_rate (int): Fee rate for swaps (U64)\n        min_liquidity (int): Minimum liquidity required (U64)\n    \"\"\"\n    id: str\n    bal_x: int\n    bal_y: int\n    fee_bal_x: int\n    fee_bal_y: int\n    lp_supply: int\n    fee_rate: int\n    min_liquidity: int\n\n    @field_validator('bal_x', 'bal_y', 'fee_bal_x', 'fee_bal_y', 'lp_supply', 'fee_rate', 'min_liquidity')\n    def validate_u64(cls, v):\n        \"\"\"\n        Validates that the value is a valid U64 integer.\n\n        Args:\n            v: The value to validate\n\n        Returns:\n            The validated value\n\n        Raises:\n            ValueError: If the value is not a valid U64 integer\n        \"\"\"\n        if not isinstance(v, int) or v &lt; 0 or v &gt; U64_MAX:\n            raise ValueError(f\"Value must be an U64 integer, got {v}\")\n        return v\n\n    @staticmethod\n    def from_gql_response(response: dict) -&gt; \"Pool\":\n        \"\"\"\n        Creates a Pool instance from a GraphQL response.\n\n        Args:\n            response (dict): The GraphQL response containing pool data\n\n        Returns:\n            Pool: A new Pool instance\n        \"\"\"\n        return Pool(\n            id=response[\"id\"],\n            bal_x=int(response[\"bal_x\"][\"value\"]),\n            bal_y=int(response[\"bal_y\"][\"value\"]),\n            fee_bal_x=int(response[\"fee_bal_x\"][\"value\"]),\n            fee_bal_y=int(response[\"fee_bal_y\"][\"value\"]),\n            lp_supply=int(response[\"lp_supply\"][\"value\"]),\n            fee_rate=int(response[\"fee_rate\"]),\n            min_liquidity=int(response[\"min_liquidity\"][\"value\"])\n        )\n</code></pre>"},{"location":"reference/#dipcoin.types.Pool.from_gql_response","title":"<code>from_gql_response(response)</code>  <code>staticmethod</code>","text":"<p>Creates a Pool instance from a GraphQL response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>The GraphQL response containing pool data</p> required <p>Returns:</p> Name Type Description <code>Pool</code> <code>Pool</code> <p>A new Pool instance</p> Source code in <code>dipcoin/types.py</code> <pre><code>@staticmethod\ndef from_gql_response(response: dict) -&gt; \"Pool\":\n    \"\"\"\n    Creates a Pool instance from a GraphQL response.\n\n    Args:\n        response (dict): The GraphQL response containing pool data\n\n    Returns:\n        Pool: A new Pool instance\n    \"\"\"\n    return Pool(\n        id=response[\"id\"],\n        bal_x=int(response[\"bal_x\"][\"value\"]),\n        bal_y=int(response[\"bal_y\"][\"value\"]),\n        fee_bal_x=int(response[\"fee_bal_x\"][\"value\"]),\n        fee_bal_y=int(response[\"fee_bal_y\"][\"value\"]),\n        lp_supply=int(response[\"lp_supply\"][\"value\"]),\n        fee_rate=int(response[\"fee_rate\"]),\n        min_liquidity=int(response[\"min_liquidity\"][\"value\"])\n    )\n</code></pre>"},{"location":"reference/#dipcoin.types.Pool.validate_u64","title":"<code>validate_u64(v)</code>","text":"<p>Validates that the value is a valid U64 integer.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <p>The value to validate</p> required <p>Returns:</p> Type Description <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not a valid U64 integer</p> Source code in <code>dipcoin/types.py</code> <pre><code>@field_validator('bal_x', 'bal_y', 'fee_bal_x', 'fee_bal_y', 'lp_supply', 'fee_rate', 'min_liquidity')\ndef validate_u64(cls, v):\n    \"\"\"\n    Validates that the value is a valid U64 integer.\n\n    Args:\n        v: The value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If the value is not a valid U64 integer\n    \"\"\"\n    if not isinstance(v, int) or v &lt; 0 or v &gt; U64_MAX:\n        raise ValueError(f\"Value must be an U64 integer, got {v}\")\n    return v\n</code></pre>"},{"location":"reference/#dipcoin.types.TransactionResponse","title":"<code>TransactionResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the response from a blockchain transaction.</p> <p>Attributes:</p> Name Type Description <code>digest</code> <code>str</code> <p>The transaction digest/hash</p> <code>status</code> <code>bool</code> <p>Whether the transaction was successful</p> <code>error</code> <code>str | None</code> <p>Error message if the transaction failed, None if successful</p> Source code in <code>dipcoin/types.py</code> <pre><code>class TransactionResponse(BaseModel):\n    \"\"\"\n    Represents the response from a blockchain transaction.\n\n    Attributes:\n        digest (str): The transaction digest/hash\n        status (bool): Whether the transaction was successful\n        error (str | None): Error message if the transaction failed, None if successful\n    \"\"\"\n    digest: str \n    status: bool\n    error: str | None = None\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This guide provides step-by-step tutorials for common use cases with the DipCoin SDK.</p>"},{"location":"tutorials/#working-with-liquidity-pools","title":"Working with Liquidity Pools","text":""},{"location":"tutorials/#finding-a-pool","title":"Finding a Pool","text":"<p>Before interacting with a pool, you'll need to find its ID. Here's how to do it:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def find_pool():\n    client = DipcoinClient()\n\n    # Define the token types you want to trade\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Get the pool ID\n    pool_id = await client.get_pool_id(coin_x_type, coin_y_type)\n\n    if pool_id:\n        print(f\"Found pool: {pool_id}\")\n    else:\n        print(\"No pool found for this pair\")\n</code></pre>"},{"location":"tutorials/#adding-liquidity","title":"Adding Liquidity","text":"<p>Adding liquidity to a pool is a common operation. Here's how to do it:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def add_liquidity_example():\n    client = DipcoinClient()\n\n    # Pool parameters\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Amounts to add (in smallest units)\n    coin_x_amount = 1000000000  # 1 SUI\n    coin_y_amount = 1000000     # 1 USDC\n\n    # Add liquidity with 0.5% slippage tolerance\n    result = await client.add_liquidity(\n        coin_x_type=coin_x_type,\n        coin_y_type=coin_y_type,\n        coin_x_amount=coin_x_amount,\n        coin_y_amount=coin_y_amount,\n        slippage=0.005\n    )\n\n    if result.status:\n        print(f\"Successfully added liquidity! Transaction ID: {result.digest}\")\n    else:\n        print(f\"Failed to add liquidity: {result.error}\")\n</code></pre>"},{"location":"tutorials/#removing-liquidity","title":"Removing Liquidity","text":"<p>To remove liquidity from a pool:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def remove_liquidity_example():\n    client = DipcoinClient()\n\n    # Pool parameters\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Amount of LP tokens to remove\n    lp_amount = 1000000\n\n    # Remove liquidity\n    result = await client.remove_liquidity(\n        coin_x_type=coin_x_type,\n        coin_y_type=coin_y_type,\n        lp_amount=lp_amount,\n        slippage=0.005\n    )\n\n    if result.status:\n        print(f\"Successfully removed liquidity! Transaction ID: {result.digest}\")\n    else:\n        print(f\"Failed to remove liquidity: {result.error}\")\n</code></pre>"},{"location":"tutorials/#performing-swaps","title":"Performing Swaps","text":""},{"location":"tutorials/#exact-input-swap","title":"Exact Input Swap","text":"<p>When you know exactly how much of the input token you want to spend:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def exact_input_swap():\n    client = DipcoinClient()\n\n    # Token types\n    coin_in_type = \"0x2::sui::SUI\"\n    coin_out_type = \"0x2::usdc::USDC\"\n\n    # Amount of input token to spend\n    amount_in = 1000000000  # 1 SUI\n\n    # Perform the swap with 0.5% slippage tolerance\n    result = await client.swap_exact_in(\n        coin_in_type=coin_in_type,\n        coin_out_type=coin_out_type,\n        amount_in=amount_in,\n        slippage=0.005\n    )\n\n    if result.status:\n        print(f\"Swap successful! Transaction ID: {result.digest}\")\n    else:\n        print(f\"Swap failed: {result.error}\")\n</code></pre>"},{"location":"tutorials/#exact-output-swap","title":"Exact Output Swap","text":"<p>When you know exactly how much of the output token you want to receive:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def exact_output_swap():\n    client = DipcoinClient()\n\n    # Token types\n    coin_in_type = \"0x2::sui::SUI\"\n    coin_out_type = \"0x2::usdc::USDC\"\n\n    # Amount of output token to receive\n    amount_out = 1000000  # 1 USDC\n\n    # Perform the swap with 0.5% slippage tolerance\n    result = await client.swap_exact_out(\n        coin_in_type=coin_in_type,\n        coin_out_type=coin_out_type,\n        amount_out=amount_out,\n        slippage=0.005\n    )\n\n    if result.status:\n        print(f\"Swap successful! Transaction ID: {result.digest}\")\n    else:\n        print(f\"Swap failed: {result.error}\")\n</code></pre>"},{"location":"tutorials/#error-handling","title":"Error Handling","text":"<p>The SDK provides detailed error information when operations fail. Here's how to handle errors properly:</p> <pre><code>from dipcoin import DipcoinClient\nfrom dipcoin.exceptions import PoolNotFound\n\nasync def error_handling_example():\n    client = DipcoinClient()\n\n    try:\n        result = await client.add_liquidity(\n            coin_x_type=\"0x2::sui::SUI\",\n            coin_y_type=\"0x2::usdc::USDC\",\n            coin_x_amount=1000000000,\n            coin_y_amount=1000000\n        )\n\n        if not result.status:\n            print(f\"Operation failed: {result.error}\")\n\n    except PoolNotFound as e:\n        print(f\"Pool not found: {e.message}\")\n        print(f\"Token pair: {e.coin_x_type}/{e.coin_y_type}\")\n    except ValueError as e:\n        print(f\"Invalid input: {str(e)}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {str(e)}\")\n</code></pre> <p>Common exceptions you might encounter:</p> <ul> <li><code>PoolNotFound</code>: Raised when attempting to interact with a pool that doesn't exist</li> <li><code>ValueError</code>: Raised for invalid input parameters (e.g., negative amounts, invalid slippage)</li> <li><code>Exception</code>: Raised for other unexpected errors</li> </ul>"},{"location":"tutorials/#best-practices","title":"Best Practices","text":"<ol> <li>Always Check Transaction Status: Verify the <code>status</code> field in the result object before proceeding.</li> <li>Use Appropriate Slippage: Set slippage tolerance based on market conditions and your risk tolerance.</li> <li>Handle Errors Gracefully: Implement proper error handling for failed transactions.</li> <li>Use Async/Await: The SDK is built with async/await support for better performance.</li> <li>Test on Testnet: Always test your code on testnet before deploying to mainnet.</li> <li>Monitor Coin Balances: Ensure you have sufficient balance before performing operations.</li> <li>Understand Token Decimals: Be aware of the decimal places for different tokens when specifying amounts.</li> </ol>"}]}