{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DipCoin Python SDK","text":"<p>DipCoin Python SDK is a powerful and easy-to-use library for interacting with the DipCoin Protocol on the Sui blockchain. This SDK provides a comprehensive set of tools for managing liquidity pools, performing swaps, and interacting with the DipCoin ecosystem.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd04 Liquidity Pool Management</li> <li>Add liquidity to pools</li> <li>Remove liquidity from pools</li> <li>Query pool information</li> <li>\ud83d\udcb1 Token Swaps</li> <li>Exact input swaps</li> <li>Exact output swaps</li> <li>\ud83d\udd0d Pool Discovery</li> <li>Find pool IDs for token pairs</li> <li>Query pool details and statistics</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dipcoin\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example of how to use the DipCoin SDK:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def main():\n    # Initialize the client (defaults to testnet)\n    client = DipcoinClient()\n\n    # Get pool information\n    pool = await client.get_pool(\"your_pool_id\")\n\n    # Add liquidity to a pool\n    result = await client.add_liquidity(\n        pool_id=\"your_pool_id\",\n        coin_x_type=\"0x2::sui::SUI\",\n        coin_y_type=\"0x2::usdc::USDC\",\n        coin_x_amount=1000000000,  # 1 SUI\n        coin_y_amount=1000000,     # 1 USDC\n        slippage=0.005             # 0.5% slippage\n    )\n\n    # Perform a swap\n    swap_result = await client.swap_exact_in(\n        pool_id=\"your_pool_id\",\n        coin_in_type=\"0x2::sui::SUI\",\n        coin_out_type=\"0x2::usdc::USDC\",\n        amount_in=1000000000,      # 1 SUI\n        slippage=0.005             # 0.5% slippage\n    )\n\n# Run the async function\nimport asyncio\nasyncio.run(main())\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Tutorials - Step-by-step guides for common use cases</li> <li>API Reference - Detailed documentation of all available methods and classes</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For support, please join our community or open an issue on GitHub.</p>"},{"location":"reference/","title":"Reference","text":"<p>Dipcoin Python SDK</p>"},{"location":"reference/#dipcoin.client.DipcoinClient","title":"<code>DipcoinClient</code>","text":"<p>A client for interacting with the Dipcoin Protocol on Sui blockchain.</p> <p>This client provides methods to interact with Dipcoin's liquidity pools, including adding/removing liquidity and performing swaps.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>str</code> <p>The network to connect to (e.g., \"testnet\", \"mainnet\")</p> <code>client</code> <code>AsyncGqlClient</code> <p>The Sui GraphQL client instance</p> Source code in <code>dipcoin/client.py</code> <pre><code>class DipcoinClient:\n    \"\"\"A client for interacting with the Dipcoin Protocol on Sui blockchain.\n\n    This client provides methods to interact with Dipcoin's liquidity pools,\n    including adding/removing liquidity and performing swaps.\n\n    Attributes:\n        network (str): The network to connect to (e.g., \"testnet\", \"mainnet\")\n        client (AsyncGqlClient): The Sui GraphQL client instance\n    \"\"\"\n\n    def __init__(\n        self, \n        network: str = \"testnet\"\n    ):\n        \"\"\"Initialize the Dipcoin client.\n\n        Args:\n            network (str, optional): The network to connect to. Defaults to \"testnet\".\n        \"\"\"\n        cfg = PysuiConfiguration(group_name=PysuiConfiguration.SUI_GQL_RPC_GROUP )\n        self.client = AsyncGqlClient(pysui_config=cfg,write_schema=False)\n        self.network = network\n\n    async def get_pool(self, pool_id: str) -&gt; Pool | None:\n        \"\"\"Retrieve information about a specific liquidity pool.\n\n        Args:\n            pool_id (str): The unique identifier of the pool to query.\n\n        Returns:\n            Pool | None: A Pool object containing the pool's information if found,\n                        None if the pool doesn't exist.\n\n        Raises:\n            Exception: If there's an error parsing the pool data or an unknown error occurs.\n        \"\"\"\n        qres = await self.client.execute_query_node(\n            with_node=qn.GetObject(\n                object_id=pool_id\n            )\n        )\n        res = handle_result(qres)\n        if isinstance(res, ObjectReadGQL):\n            try:\n                return Pool.from_gql_response(res.content)\n            except:\n                raise Exception(f\"Unknown error: {res}\")\n        elif isinstance(res, NoopGQL):\n            return None\n        else:\n            raise Exception(f\"Unknown error: {res}\")\n\n    async def get_pool_id(self, coin_x_type: str, coin_y_type: str) -&gt; str | None:\n        \"\"\"Get the pool ID for a given pair of tokens.\n\n        Args:\n            coin_x_type (str): The type of the first token in the pair.\n            coin_y_type (str): The type of the second token in the pair.\n\n        Returns:\n            str | None: The pool ID if found, None if no pool exists for the given pair.\n        \"\"\"\n        # TODO: Implement pool ID retrieval logic\n        pass\n\n    async def add_liquidity(\n        self,\n        pool_id: str,\n        coin_x_type: str,\n        coin_y_type: str,\n        coin_x_amount: int,\n        coin_y_amount: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Add liquidity to a pool.\n\n        This method allows users to provide liquidity to a pool by depositing both tokens\n        in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.\n\n        Args:\n            pool_id (str): The ID of the pool to add liquidity to.\n            coin_x_type (str): The type of the first token.\n            coin_y_type (str): The type of the second token.\n            coin_x_amount (int): The amount of the first token to deposit.\n            coin_y_amount (int): The amount of the second token to deposit.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - tx_id (str): The transaction ID if successful, empty string if failed\n                - status (bool): True if the transaction was successful, False otherwise\n                - error (str, optional): Error message if the transaction failed\n\n        Raises:\n            ValueError: If amounts are invalid or slippage is out of range\n        \"\"\"\n        try:\n            # Ensure correct order of typeX and typeY\n            new_type_x, new_type_y = sort_type(coin_x_type, coin_y_type)\n            is_change = new_type_x != coin_x_type\n            coin_x_type = new_type_x\n            coin_y_type = new_type_y\n\n            if is_change:\n                coin_x_amount, coin_y_amount = coin_y_amount, coin_x_amount\n\n            # Validate input amounts\n            if coin_x_amount &lt;= 0 or coin_y_amount &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n            # Get pool information\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            # Calculate optimal amounts\n            coin_x_desired, coin_y_desired = calc_optimal_coin_values(\n                Decimal(str(coin_x_amount)),\n                Decimal(str(coin_y_amount)),\n                Decimal(str(pool.bal_x.value)),\n                Decimal(str(pool.bal_y.value))\n            )\n            # Calculate minimum accepted amounts (considering slippage)\n            coin_x_min = int(coin_x_desired * Decimal(1.0 - slippage))\n            coin_y_min = int(coin_y_desired * Decimal(1.0 - slippage))\n\n            # Create transaction\n            txn = SuiTransaction(client=self.client)\n\n            # Split X token\n            split_coin_x = await self._split_coin(\n                self.client.config.active_address,\n                coin_x_type,\n                coin_x_amount,\n                txn\n            )\n\n            # Split Y token\n            split_coin_y = await self._split_coin(\n                self.client.config.active_address,\n                coin_y_type,\n                coin_y_amount,\n                txn\n            )\n\n            # Call contract to add liquidity\n            await txn.move_call(\n                target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::add_liquidity\",\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_x,\n                    coin_x_min,\n                    split_coin_y,\n                    coin_y_min\n                ],\n                type_arguments=[coin_x_type, coin_y_type]\n            )\n            # Execute transaction\n            tx_data = await txn.build_and_sign()\n            tx_result = await txn.client.execute_query_node(\n                with_node=qn.ExecuteTransaction(**tx_data)\n            )\n            tx_result = handle_result(tx_result)\n\n            return {\n                \"tx_id\": tx_result.digest,\n                \"status\": True\n            }\n\n        except Exception as e:\n            return {\n                \"tx_id\": \"\",\n                \"status\": False,\n                \"error\": str(e)\n            }\n\n    async def _split_coin(\n        self,\n        owner_address: str,\n        coin_type: str,\n        amount: int,\n        txn: SuiTransaction\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Split coin\n\n        Args:\n            owner_address: Owner address\n            coin_type: Coin type\n            amount: Split amount\n            txn: Transaction object\n\n        Returns:\n            Dict[str, Any]: Split coin info\n        \"\"\"\n        # Get coin list\n        coins = await self.client.execute_query_node(\n            with_node=qn.GetCoins(\n                owner=owner_address,\n                coin_type=coin_type\n            )\n        )\n        coins_data = handle_result(coins)\n\n        if not coins_data or len(coins_data.data) == 0:\n            raise ValueError(f\"no {coin_type} coins available\")\n\n        # Filter out enough coins\n        selected_coins = []\n        total_amount = 0\n        for coin in coins_data.data:\n            selected_coins.append(coin.coin_object_id)\n            total_amount += int(coin.balance)\n            if total_amount &gt;= amount:\n                break\n\n        if not selected_coins or total_amount &lt; amount:\n            raise ValueError(\n                f\"{coin_type} balance is not enough, current total balance:{total_amount}\"\n            )\n\n        # Merge coins (if selected coins are more than 1)\n        if len(selected_coins) &gt; 1:\n            await txn.merge_coins(\n                merge_to=selected_coins[0],\n                merge_from=selected_coins[1:],\n            )\n\n        # Split out the specified amount of coins\n        split_result = await txn.split_coin(\n            coin=selected_coins[0],\n            amounts=[amount]\n        )\n        return split_result\n\n    async def remove_liquidity(\n        self,\n        pool_id: str,\n        coin_x_type: str,\n        coin_y_type: str,\n        lp_amount: int,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Remove liquidity from a pool.\n\n        This method allows users to withdraw their liquidity from a pool by burning\n        their LP tokens. The user will receive both tokens in the pair in proportion\n        to their share of the pool.\n\n        Args:\n            pool_id (str): The ID of the pool to remove liquidity from.\n            coin_x_type (str): The type of the first token in the pair.\n            coin_y_type (str): The type of the second token in the pair.\n            lp_amount (int): The amount of LP tokens to burn.\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - tx_id (str): The transaction ID if successful, empty string if failed\n                - status (bool): True if the transaction was successful, False otherwise\n                - error (str, optional): Error message if the transaction failed\n\n        Raises:\n            ValueError: If the LP amount is invalid or pool information cannot be retrieved\n        \"\"\"\n        try:\n            if lp_amount &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n\n            coin_x_type, coin_y_type, lp_type = sort_and_get_lp_type(\n                CONTRACT_CONSTANTS[self.network].package_id,\n                coin_x_type,\n                coin_y_type\n            )\n\n            # Get pool info\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split LP coin\n            split_lp_coin = await self._split_coin(\n                self.client.config.active_address,\n                lp_type,\n                lp_amount,\n                txn\n            )\n\n            # Call contract to remove liquidity\n            await txn.move_call(\n                target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::remove_liquidity\",\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_lp_coin\n                ],\n                type_arguments=[coin_x_type, coin_y_type]\n            )\n\n            # Execute transaction\n            tx_data = await txn.build_and_sign()\n            tx_result = await txn.client.execute_query_node(\n                with_node=qn.ExecuteTransaction(**tx_data)\n            )\n            tx_result = handle_result(tx_result)\n\n            return {\n                \"tx_id\": tx_result.digest,\n                \"status\": True\n            }\n\n        except Exception as e:\n            return {\n                \"tx_id\": \"\",\n                \"status\": False,\n                \"error\": str(e)\n            }\n\n    async def swap_exact_in(\n        self,\n        pool_id: str,\n        coin_in_type: str,\n        coin_out_type: str,\n        amount_in: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Swap an exact amount of input tokens for output tokens.\n\n        This method performs a swap where the user specifies the exact amount of input\n        tokens they want to spend. The output amount is calculated based on the pool's\n        current price and liquidity.\n\n        Args:\n            pool_id (str): The ID of the pool to perform the swap in.\n            coin_in_type (str): The type of the input token.\n            coin_out_type (str): The type of the output token.\n            amount_in (int): The exact amount of input tokens to spend.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - tx_id (str): The transaction ID if successful, empty string if failed\n                - status (bool): True if the transaction was successful, False otherwise\n                - error (str, optional): Error message if the transaction failed\n\n        Raises:\n            ValueError: If the input amount is invalid or slippage is out of range\n        \"\"\"\n        try:\n            if amount_in &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n            # Get pool info\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split X coin\n            split_coin_in = await self._split_coin(\n                self.client.config.active_address,\n                coin_in_type,\n                amount_in,\n                txn\n            )\n\n            if coin_in_type == pool_x_type:\n                expected_amount_out = get_amount_out(\n                    Decimal(str(pool.fee_rate.value)),\n                    Decimal(str(amount_in)),\n                    Decimal(str(pool.bal_x.value)),\n                    Decimal(str(pool.bal_y.value))\n                )\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_x_to_y\"\n            else:\n                expected_amount_out = get_amount_out(\n                    Decimal(str(pool.fee_rate.value)),\n                    Decimal(str(amount_in)),\n                    Decimal(str(pool.bal_y.value)),\n                    Decimal(str(pool.bal_x.value))\n                )\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_y_to_x\"\n\n            # Calculate minimum output amount (considering slippage)\n            min_amount_out = int(expected_amount_out * Decimal(1.0 - slippage))\n\n            # Call contract to swap\n            await txn.move_call(\n                target=target,\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_in,\n                    min_amount_out\n                ],\n                type_arguments=[pool_x_type, pool_y_type]\n            )\n\n            # Execute transaction\n            tx_data = await txn.build_and_sign()\n            tx_result = await txn.client.execute_query_node(\n                with_node=qn.ExecuteTransaction(**tx_data)\n            )\n            tx_result = handle_result(tx_result)\n\n            return {\n                \"tx_id\": tx_result.digest,\n                \"status\": True\n            }\n\n        except Exception as e:\n            return {\n                \"tx_id\": \"\",\n                \"status\": False,\n                \"error\": str(e)\n            }\n\n    async def swap_exact_out(\n        self,\n        pool_id: str,\n        coin_in_type: str,\n        coin_out_type: str,\n        amount_out: int,\n        slippage: float = DEFAULT_SLIPPAGE,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Swap input tokens for an exact amount of output tokens.\n\n        This method performs a swap where the user specifies the exact amount of output\n        tokens they want to receive. The required input amount is calculated based on\n        the pool's current price and liquidity.\n\n        Args:\n            pool_id (str): The ID of the pool to perform the swap in.\n            coin_in_type (str): The type of the input token.\n            coin_out_type (str): The type of the output token.\n            amount_out (int): The exact amount of output tokens to receive.\n            slippage (float, optional): The maximum acceptable slippage in percentage.\n                                      Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n        Returns:\n            Dict[str, Any]: A dictionary containing:\n                - tx_id (str): The transaction ID if successful, empty string if failed\n                - status (bool): True if the transaction was successful, False otherwise\n                - error (str, optional): Error message if the transaction failed\n\n        Raises:\n            ValueError: If the output amount is invalid or slippage is out of range\n        \"\"\"\n        try:\n            if amount_out &lt;= 0:\n                raise ValueError(\"Amount must be greater than 0\")\n            if slippage &gt;= 1.0 or slippage &lt; 0.0:\n                raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n            # Get pool info\n            pool = await self.get_pool(pool_id)\n            if not pool:\n                raise ValueError(\"Failed to get pool info\")\n\n            pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n            if pool_x_type == coin_in_type:\n                balance_x = pool.bal_x.value\n                balance_y = pool.bal_y.value\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_x_to_exact_y\"\n            else:\n                balance_x = pool.bal_y.value\n                balance_y = pool.bal_x.value\n                target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_y_to_exact_x\"\n\n            expected_amount_in = get_amount_in(\n                Decimal(str(pool.fee_rate.value)),\n                Decimal(str(amount_out)),\n                Decimal(str(balance_x)),\n                Decimal(str(balance_y))\n            )\n            max_amount_in = int(expected_amount_in / Decimal(1.0 - slippage))\n\n            # Build transaction block\n            txn = SuiTransaction(client=self.client)\n\n            # Split X coin\n            split_coin_in = await self._split_coin(\n                self.client.config.active_address,\n                coin_in_type,\n                max_amount_in,\n                txn\n            )\n\n            # Call contract to swap\n            await txn.move_call(\n                target=target,\n                arguments=[\n                    CONTRACT_CONSTANTS[self.network].version_id,\n                    CONTRACT_CONSTANTS[self.network].global_id,\n                    pool_id,\n                    split_coin_in,\n                    amount_out\n                ],\n                type_arguments=[pool_x_type, pool_y_type]\n            )\n\n            # Execute transaction\n            tx_data = await txn.build_and_sign()\n            tx_result = await txn.client.execute_query_node(\n                with_node=qn.ExecuteTransaction(**tx_data)\n            )\n            tx_result = handle_result(tx_result)\n\n            return {\n                \"tx_id\": tx_result.digest,\n                \"status\": True\n            }\n\n        except Exception as e:\n            return {\n                \"tx_id\": \"\",\n                \"status\": False,\n                \"error\": str(e)\n            }\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.__init__","title":"<code>__init__(network='testnet')</code>","text":"<p>Initialize the Dipcoin client.</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>str</code> <p>The network to connect to. Defaults to \"testnet\".</p> <code>'testnet'</code> Source code in <code>dipcoin/client.py</code> <pre><code>def __init__(\n    self, \n    network: str = \"testnet\"\n):\n    \"\"\"Initialize the Dipcoin client.\n\n    Args:\n        network (str, optional): The network to connect to. Defaults to \"testnet\".\n    \"\"\"\n    cfg = PysuiConfiguration(group_name=PysuiConfiguration.SUI_GQL_RPC_GROUP )\n    self.client = AsyncGqlClient(pysui_config=cfg,write_schema=False)\n    self.network = network\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.add_liquidity","title":"<code>add_liquidity(pool_id, coin_x_type, coin_y_type, coin_x_amount, coin_y_amount, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Add liquidity to a pool.</p> <p>This method allows users to provide liquidity to a pool by depositing both tokens in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The ID of the pool to add liquidity to.</p> required <code>coin_x_type</code> <code>str</code> <p>The type of the first token.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token.</p> required <code>coin_x_amount</code> <code>int</code> <p>The amount of the first token to deposit.</p> required <code>coin_y_amount</code> <code>int</code> <p>The amount of the second token to deposit.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to DEFAULT_SLIPPAGE (0.5%).</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - tx_id (str): The transaction ID if successful, empty string if failed - status (bool): True if the transaction was successful, False otherwise - error (str, optional): Error message if the transaction failed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If amounts are invalid or slippage is out of range</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def add_liquidity(\n    self,\n    pool_id: str,\n    coin_x_type: str,\n    coin_y_type: str,\n    coin_x_amount: int,\n    coin_y_amount: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; Dict[str, Any]:\n    \"\"\"Add liquidity to a pool.\n\n    This method allows users to provide liquidity to a pool by depositing both tokens\n    in the pair. The amounts are automatically adjusted to maintain the pool's price ratio.\n\n    Args:\n        pool_id (str): The ID of the pool to add liquidity to.\n        coin_x_type (str): The type of the first token.\n        coin_y_type (str): The type of the second token.\n        coin_x_amount (int): The amount of the first token to deposit.\n        coin_y_amount (int): The amount of the second token to deposit.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - tx_id (str): The transaction ID if successful, empty string if failed\n            - status (bool): True if the transaction was successful, False otherwise\n            - error (str, optional): Error message if the transaction failed\n\n    Raises:\n        ValueError: If amounts are invalid or slippage is out of range\n    \"\"\"\n    try:\n        # Ensure correct order of typeX and typeY\n        new_type_x, new_type_y = sort_type(coin_x_type, coin_y_type)\n        is_change = new_type_x != coin_x_type\n        coin_x_type = new_type_x\n        coin_y_type = new_type_y\n\n        if is_change:\n            coin_x_amount, coin_y_amount = coin_y_amount, coin_x_amount\n\n        # Validate input amounts\n        if coin_x_amount &lt;= 0 or coin_y_amount &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(r\"Slippage must be less than 100% and greater than 0%\")\n\n        # Get pool information\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        # Calculate optimal amounts\n        coin_x_desired, coin_y_desired = calc_optimal_coin_values(\n            Decimal(str(coin_x_amount)),\n            Decimal(str(coin_y_amount)),\n            Decimal(str(pool.bal_x.value)),\n            Decimal(str(pool.bal_y.value))\n        )\n        # Calculate minimum accepted amounts (considering slippage)\n        coin_x_min = int(coin_x_desired * Decimal(1.0 - slippage))\n        coin_y_min = int(coin_y_desired * Decimal(1.0 - slippage))\n\n        # Create transaction\n        txn = SuiTransaction(client=self.client)\n\n        # Split X token\n        split_coin_x = await self._split_coin(\n            self.client.config.active_address,\n            coin_x_type,\n            coin_x_amount,\n            txn\n        )\n\n        # Split Y token\n        split_coin_y = await self._split_coin(\n            self.client.config.active_address,\n            coin_y_type,\n            coin_y_amount,\n            txn\n        )\n\n        # Call contract to add liquidity\n        await txn.move_call(\n            target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::add_liquidity\",\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_x,\n                coin_x_min,\n                split_coin_y,\n                coin_y_min\n            ],\n            type_arguments=[coin_x_type, coin_y_type]\n        )\n        # Execute transaction\n        tx_data = await txn.build_and_sign()\n        tx_result = await txn.client.execute_query_node(\n            with_node=qn.ExecuteTransaction(**tx_data)\n        )\n        tx_result = handle_result(tx_result)\n\n        return {\n            \"tx_id\": tx_result.digest,\n            \"status\": True\n        }\n\n    except Exception as e:\n        return {\n            \"tx_id\": \"\",\n            \"status\": False,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.get_pool","title":"<code>get_pool(pool_id)</code>  <code>async</code>","text":"<p>Retrieve information about a specific liquidity pool.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The unique identifier of the pool to query.</p> required <p>Returns:</p> Type Description <code>Pool | None</code> <p>Pool | None: A Pool object containing the pool's information if found,         None if the pool doesn't exist.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If there's an error parsing the pool data or an unknown error occurs.</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def get_pool(self, pool_id: str) -&gt; Pool | None:\n    \"\"\"Retrieve information about a specific liquidity pool.\n\n    Args:\n        pool_id (str): The unique identifier of the pool to query.\n\n    Returns:\n        Pool | None: A Pool object containing the pool's information if found,\n                    None if the pool doesn't exist.\n\n    Raises:\n        Exception: If there's an error parsing the pool data or an unknown error occurs.\n    \"\"\"\n    qres = await self.client.execute_query_node(\n        with_node=qn.GetObject(\n            object_id=pool_id\n        )\n    )\n    res = handle_result(qres)\n    if isinstance(res, ObjectReadGQL):\n        try:\n            return Pool.from_gql_response(res.content)\n        except:\n            raise Exception(f\"Unknown error: {res}\")\n    elif isinstance(res, NoopGQL):\n        return None\n    else:\n        raise Exception(f\"Unknown error: {res}\")\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.get_pool_id","title":"<code>get_pool_id(coin_x_type, coin_y_type)</code>  <code>async</code>","text":"<p>Get the pool ID for a given pair of tokens.</p> <p>Parameters:</p> Name Type Description Default <code>coin_x_type</code> <code>str</code> <p>The type of the first token in the pair.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token in the pair.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The pool ID if found, None if no pool exists for the given pair.</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def get_pool_id(self, coin_x_type: str, coin_y_type: str) -&gt; str | None:\n    \"\"\"Get the pool ID for a given pair of tokens.\n\n    Args:\n        coin_x_type (str): The type of the first token in the pair.\n        coin_y_type (str): The type of the second token in the pair.\n\n    Returns:\n        str | None: The pool ID if found, None if no pool exists for the given pair.\n    \"\"\"\n    # TODO: Implement pool ID retrieval logic\n    pass\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.remove_liquidity","title":"<code>remove_liquidity(pool_id, coin_x_type, coin_y_type, lp_amount)</code>  <code>async</code>","text":"<p>Remove liquidity from a pool.</p> <p>This method allows users to withdraw their liquidity from a pool by burning their LP tokens. The user will receive both tokens in the pair in proportion to their share of the pool.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The ID of the pool to remove liquidity from.</p> required <code>coin_x_type</code> <code>str</code> <p>The type of the first token in the pair.</p> required <code>coin_y_type</code> <code>str</code> <p>The type of the second token in the pair.</p> required <code>lp_amount</code> <code>int</code> <p>The amount of LP tokens to burn.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - tx_id (str): The transaction ID if successful, empty string if failed - status (bool): True if the transaction was successful, False otherwise - error (str, optional): Error message if the transaction failed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the LP amount is invalid or pool information cannot be retrieved</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def remove_liquidity(\n    self,\n    pool_id: str,\n    coin_x_type: str,\n    coin_y_type: str,\n    lp_amount: int,\n) -&gt; Dict[str, Any]:\n    \"\"\"Remove liquidity from a pool.\n\n    This method allows users to withdraw their liquidity from a pool by burning\n    their LP tokens. The user will receive both tokens in the pair in proportion\n    to their share of the pool.\n\n    Args:\n        pool_id (str): The ID of the pool to remove liquidity from.\n        coin_x_type (str): The type of the first token in the pair.\n        coin_y_type (str): The type of the second token in the pair.\n        lp_amount (int): The amount of LP tokens to burn.\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - tx_id (str): The transaction ID if successful, empty string if failed\n            - status (bool): True if the transaction was successful, False otherwise\n            - error (str, optional): Error message if the transaction failed\n\n    Raises:\n        ValueError: If the LP amount is invalid or pool information cannot be retrieved\n    \"\"\"\n    try:\n        if lp_amount &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n\n        coin_x_type, coin_y_type, lp_type = sort_and_get_lp_type(\n            CONTRACT_CONSTANTS[self.network].package_id,\n            coin_x_type,\n            coin_y_type\n        )\n\n        # Get pool info\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split LP coin\n        split_lp_coin = await self._split_coin(\n            self.client.config.active_address,\n            lp_type,\n            lp_amount,\n            txn\n        )\n\n        # Call contract to remove liquidity\n        await txn.move_call(\n            target=f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::remove_liquidity\",\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_lp_coin\n            ],\n            type_arguments=[coin_x_type, coin_y_type]\n        )\n\n        # Execute transaction\n        tx_data = await txn.build_and_sign()\n        tx_result = await txn.client.execute_query_node(\n            with_node=qn.ExecuteTransaction(**tx_data)\n        )\n        tx_result = handle_result(tx_result)\n\n        return {\n            \"tx_id\": tx_result.digest,\n            \"status\": True\n        }\n\n    except Exception as e:\n        return {\n            \"tx_id\": \"\",\n            \"status\": False,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.swap_exact_in","title":"<code>swap_exact_in(pool_id, coin_in_type, coin_out_type, amount_in, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Swap an exact amount of input tokens for output tokens.</p> <p>This method performs a swap where the user specifies the exact amount of input tokens they want to spend. The output amount is calculated based on the pool's current price and liquidity.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The ID of the pool to perform the swap in.</p> required <code>coin_in_type</code> <code>str</code> <p>The type of the input token.</p> required <code>coin_out_type</code> <code>str</code> <p>The type of the output token.</p> required <code>amount_in</code> <code>int</code> <p>The exact amount of input tokens to spend.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to DEFAULT_SLIPPAGE (0.5%).</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - tx_id (str): The transaction ID if successful, empty string if failed - status (bool): True if the transaction was successful, False otherwise - error (str, optional): Error message if the transaction failed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input amount is invalid or slippage is out of range</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def swap_exact_in(\n    self,\n    pool_id: str,\n    coin_in_type: str,\n    coin_out_type: str,\n    amount_in: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; Dict[str, Any]:\n    \"\"\"Swap an exact amount of input tokens for output tokens.\n\n    This method performs a swap where the user specifies the exact amount of input\n    tokens they want to spend. The output amount is calculated based on the pool's\n    current price and liquidity.\n\n    Args:\n        pool_id (str): The ID of the pool to perform the swap in.\n        coin_in_type (str): The type of the input token.\n        coin_out_type (str): The type of the output token.\n        amount_in (int): The exact amount of input tokens to spend.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - tx_id (str): The transaction ID if successful, empty string if failed\n            - status (bool): True if the transaction was successful, False otherwise\n            - error (str, optional): Error message if the transaction failed\n\n    Raises:\n        ValueError: If the input amount is invalid or slippage is out of range\n    \"\"\"\n    try:\n        if amount_in &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n        # Get pool info\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split X coin\n        split_coin_in = await self._split_coin(\n            self.client.config.active_address,\n            coin_in_type,\n            amount_in,\n            txn\n        )\n\n        if coin_in_type == pool_x_type:\n            expected_amount_out = get_amount_out(\n                Decimal(str(pool.fee_rate.value)),\n                Decimal(str(amount_in)),\n                Decimal(str(pool.bal_x.value)),\n                Decimal(str(pool.bal_y.value))\n            )\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_x_to_y\"\n        else:\n            expected_amount_out = get_amount_out(\n                Decimal(str(pool.fee_rate.value)),\n                Decimal(str(amount_in)),\n                Decimal(str(pool.bal_y.value)),\n                Decimal(str(pool.bal_x.value))\n            )\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_exact_y_to_x\"\n\n        # Calculate minimum output amount (considering slippage)\n        min_amount_out = int(expected_amount_out * Decimal(1.0 - slippage))\n\n        # Call contract to swap\n        await txn.move_call(\n            target=target,\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_in,\n                min_amount_out\n            ],\n            type_arguments=[pool_x_type, pool_y_type]\n        )\n\n        # Execute transaction\n        tx_data = await txn.build_and_sign()\n        tx_result = await txn.client.execute_query_node(\n            with_node=qn.ExecuteTransaction(**tx_data)\n        )\n        tx_result = handle_result(tx_result)\n\n        return {\n            \"tx_id\": tx_result.digest,\n            \"status\": True\n        }\n\n    except Exception as e:\n        return {\n            \"tx_id\": \"\",\n            \"status\": False,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"reference/#dipcoin.client.DipcoinClient.swap_exact_out","title":"<code>swap_exact_out(pool_id, coin_in_type, coin_out_type, amount_out, slippage=DEFAULT_SLIPPAGE)</code>  <code>async</code>","text":"<p>Swap input tokens for an exact amount of output tokens.</p> <p>This method performs a swap where the user specifies the exact amount of output tokens they want to receive. The required input amount is calculated based on the pool's current price and liquidity.</p> <p>Parameters:</p> Name Type Description Default <code>pool_id</code> <code>str</code> <p>The ID of the pool to perform the swap in.</p> required <code>coin_in_type</code> <code>str</code> <p>The type of the input token.</p> required <code>coin_out_type</code> <code>str</code> <p>The type of the output token.</p> required <code>amount_out</code> <code>int</code> <p>The exact amount of output tokens to receive.</p> required <code>slippage</code> <code>float</code> <p>The maximum acceptable slippage in percentage.                       Defaults to DEFAULT_SLIPPAGE (0.5%).</p> <code>DEFAULT_SLIPPAGE</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary containing: - tx_id (str): The transaction ID if successful, empty string if failed - status (bool): True if the transaction was successful, False otherwise - error (str, optional): Error message if the transaction failed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the output amount is invalid or slippage is out of range</p> Source code in <code>dipcoin/client.py</code> <pre><code>async def swap_exact_out(\n    self,\n    pool_id: str,\n    coin_in_type: str,\n    coin_out_type: str,\n    amount_out: int,\n    slippage: float = DEFAULT_SLIPPAGE,\n) -&gt; Dict[str, Any]:\n    \"\"\"Swap input tokens for an exact amount of output tokens.\n\n    This method performs a swap where the user specifies the exact amount of output\n    tokens they want to receive. The required input amount is calculated based on\n    the pool's current price and liquidity.\n\n    Args:\n        pool_id (str): The ID of the pool to perform the swap in.\n        coin_in_type (str): The type of the input token.\n        coin_out_type (str): The type of the output token.\n        amount_out (int): The exact amount of output tokens to receive.\n        slippage (float, optional): The maximum acceptable slippage in percentage.\n                                  Defaults to DEFAULT_SLIPPAGE (0.5%).\n\n    Returns:\n        Dict[str, Any]: A dictionary containing:\n            - tx_id (str): The transaction ID if successful, empty string if failed\n            - status (bool): True if the transaction was successful, False otherwise\n            - error (str, optional): Error message if the transaction failed\n\n    Raises:\n        ValueError: If the output amount is invalid or slippage is out of range\n    \"\"\"\n    try:\n        if amount_out &lt;= 0:\n            raise ValueError(\"Amount must be greater than 0\")\n        if slippage &gt;= 1.0 or slippage &lt; 0.0:\n            raise ValueError(\"Slippage must be less than 100% and greater than 0%\")\n\n        # Get pool info\n        pool = await self.get_pool(pool_id)\n        if not pool:\n            raise ValueError(\"Failed to get pool info\")\n\n        pool_x_type, pool_y_type = sort_type(coin_in_type, coin_out_type)\n        if pool_x_type == coin_in_type:\n            balance_x = pool.bal_x.value\n            balance_y = pool.bal_y.value\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_x_to_exact_y\"\n        else:\n            balance_x = pool.bal_y.value\n            balance_y = pool.bal_x.value\n            target = f\"{CONTRACT_CONSTANTS[self.network].package_id}::router::swap_y_to_exact_x\"\n\n        expected_amount_in = get_amount_in(\n            Decimal(str(pool.fee_rate.value)),\n            Decimal(str(amount_out)),\n            Decimal(str(balance_x)),\n            Decimal(str(balance_y))\n        )\n        max_amount_in = int(expected_amount_in / Decimal(1.0 - slippage))\n\n        # Build transaction block\n        txn = SuiTransaction(client=self.client)\n\n        # Split X coin\n        split_coin_in = await self._split_coin(\n            self.client.config.active_address,\n            coin_in_type,\n            max_amount_in,\n            txn\n        )\n\n        # Call contract to swap\n        await txn.move_call(\n            target=target,\n            arguments=[\n                CONTRACT_CONSTANTS[self.network].version_id,\n                CONTRACT_CONSTANTS[self.network].global_id,\n                pool_id,\n                split_coin_in,\n                amount_out\n            ],\n            type_arguments=[pool_x_type, pool_y_type]\n        )\n\n        # Execute transaction\n        tx_data = await txn.build_and_sign()\n        tx_result = await txn.client.execute_query_node(\n            with_node=qn.ExecuteTransaction(**tx_data)\n        )\n        tx_result = handle_result(tx_result)\n\n        return {\n            \"tx_id\": tx_result.digest,\n            \"status\": True\n        }\n\n    except Exception as e:\n        return {\n            \"tx_id\": \"\",\n            \"status\": False,\n            \"error\": str(e)\n        }\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>This guide provides step-by-step tutorials for common use cases with the DipCoin SDK.</p>"},{"location":"tutorials/#working-with-liquidity-pools","title":"Working with Liquidity Pools","text":""},{"location":"tutorials/#finding-a-pool","title":"Finding a Pool","text":"<p>Before interacting with a pool, you'll need to find its ID. Here's how to do it:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def find_pool():\n    client = DipcoinClient()\n\n    # Define the token types you want to trade\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Get the pool ID\n    pool_id = await client.get_pool_id(coin_x_type, coin_y_type)\n\n    if pool_id:\n        print(f\"Found pool: {pool_id}\")\n    else:\n        print(\"No pool found for this pair\")\n</code></pre>"},{"location":"tutorials/#adding-liquidity","title":"Adding Liquidity","text":"<p>Adding liquidity to a pool is a common operation. Here's how to do it:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def add_liquidity_example():\n    client = DipcoinClient()\n\n    # Pool parameters\n    pool_id = \"your_pool_id\"\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Amounts to add (in smallest units)\n    coin_x_amount = 1000000000  # 1 SUI\n    coin_y_amount = 1000000     # 1 USDC\n\n    # Add liquidity with 0.5% slippage tolerance\n    result = await client.add_liquidity(\n        pool_id=pool_id,\n        coin_x_type=coin_x_type,\n        coin_y_type=coin_y_type,\n        coin_x_amount=coin_x_amount,\n        coin_y_amount=coin_y_amount,\n        slippage=0.005\n    )\n\n    if result[\"status\"]:\n        print(f\"Successfully added liquidity! Transaction ID: {result['tx_id']}\")\n    else:\n        print(f\"Failed to add liquidity: {result.get('error')}\")\n</code></pre>"},{"location":"tutorials/#removing-liquidity","title":"Removing Liquidity","text":"<p>To remove liquidity from a pool:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def remove_liquidity_example():\n    client = DipcoinClient()\n\n    # Pool parameters\n    pool_id = \"your_pool_id\"\n    coin_x_type = \"0x2::sui::SUI\"\n    coin_y_type = \"0x2::usdc::USDC\"\n\n    # Amount of LP tokens to remove\n    lp_amount = 1000000\n\n    # Remove liquidity\n    result = await client.remove_liquidity(\n        pool_id=pool_id,\n        coin_x_type=coin_x_type,\n        coin_y_type=coin_y_type,\n        lp_amount=lp_amount\n    )\n\n    if result[\"status\"]:\n        print(f\"Successfully removed liquidity! Transaction ID: {result['tx_id']}\")\n    else:\n        print(f\"Failed to remove liquidity: {result.get('error')}\")\n</code></pre>"},{"location":"tutorials/#performing-swaps","title":"Performing Swaps","text":""},{"location":"tutorials/#exact-input-swap","title":"Exact Input Swap","text":"<p>When you know exactly how much of the input token you want to spend:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def exact_input_swap():\n    client = DipcoinClient()\n\n    # Pool parameters\n    pool_id = \"your_pool_id\"\n    coin_in_type = \"0x2::sui::SUI\"\n    coin_out_type = \"0x2::usdc::USDC\"\n\n    # Amount of input token to spend\n    amount_in = 1000000000  # 1 SUI\n\n    # Perform the swap with 0.5% slippage tolerance\n    result = await client.swap_exact_in(\n        pool_id=pool_id,\n        coin_in_type=coin_in_type,\n        coin_out_type=coin_out_type,\n        amount_in=amount_in,\n        slippage=0.005\n    )\n\n    if result[\"status\"]:\n        print(f\"Swap successful! Transaction ID: {result['tx_id']}\")\n    else:\n        print(f\"Swap failed: {result.get('error')}\")\n</code></pre>"},{"location":"tutorials/#exact-output-swap","title":"Exact Output Swap","text":"<p>When you know exactly how much of the output token you want to receive:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def exact_output_swap():\n    client = DipcoinClient()\n\n    # Pool parameters\n    pool_id = \"your_pool_id\"\n    coin_in_type = \"0x2::sui::SUI\"\n    coin_out_type = \"0x2::usdc::USDC\"\n\n    # Amount of output token to receive\n    amount_out = 1000000  # 1 USDC\n\n    # Perform the swap with 0.5% slippage tolerance\n    result = await client.swap_exact_out(\n        pool_id=pool_id,\n        coin_in_type=coin_in_type,\n        coin_out_type=coin_out_type,\n        amount_out=amount_out,\n        slippage=0.005\n    )\n\n    if result[\"status\"]:\n        print(f\"Swap successful! Transaction ID: {result['tx_id']}\")\n    else:\n        print(f\"Swap failed: {result.get('error')}\")\n</code></pre>"},{"location":"tutorials/#error-handling","title":"Error Handling","text":"<p>The SDK provides detailed error information when operations fail. Here's how to handle errors properly:</p> <pre><code>from dipcoin import DipcoinClient\n\nasync def error_handling_example():\n    client = DipcoinClient()\n\n    try:\n        result = await client.add_liquidity(\n            pool_id=\"invalid_pool_id\",\n            coin_x_type=\"0x2::sui::SUI\",\n            coin_y_type=\"0x2::usdc::USDC\",\n            coin_x_amount=1000000000,\n            coin_y_amount=1000000\n        )\n\n        if not result[\"status\"]:\n            print(f\"Operation failed: {result.get('error')}\")\n\n    except Exception as e:\n        print(f\"An unexpected error occurred: {str(e)}\")\n</code></pre>"},{"location":"tutorials/#best-practices","title":"Best Practices","text":"<ol> <li>Always Check Transaction Status: Verify the <code>status</code> field in the result dictionary before proceeding.</li> <li>Use Appropriate Slippage: Set slippage tolerance based on market conditions and your risk tolerance.</li> <li>Handle Errors Gracefully: Implement proper error handling for failed transactions.</li> <li>Use Async/Await: The SDK is built with async/await support for better performance.</li> <li>Test on Testnet: Always test your code on testnet before deploying to mainnet.</li> </ol>"}]}